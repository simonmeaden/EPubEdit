<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>SM Libraries: CircularBuffer&lt; T, always_accept_data_when_full, Alloc &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">SM Libraries
   &#160;<span id="projectnumber">0.1.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classCircularBuffer-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">CircularBuffer&lt; T, always_accept_data_when_full, Alloc &gt; Class Template Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>A template class that implements a circular or ring buffer.  
 <a href="classCircularBuffer.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="circularbuffer_8h_source.html">circularbuffer.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:ab5b3c8de70e924bdec71dc915365e260"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCircularBuffer.html#ab5b3c8de70e924bdec71dc915365e260">CircularBuffer</a> (int <a class="el" href="classCircularBuffer.html#a59530258197a44c29342291568f427bf">capacity</a>)</td></tr>
<tr class="memdesc:ab5b3c8de70e924bdec71dc915365e260"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor of the <a class="el" href="classCircularBuffer.html" title="A template class that implements a circular or ring buffer.">CircularBuffer</a>.  <a href="classCircularBuffer.html#ab5b3c8de70e924bdec71dc915365e260">More...</a><br /></td></tr>
<tr class="separator:ab5b3c8de70e924bdec71dc915365e260"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abacad2af962b5b0d969ad14c0fb2dc83"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCircularBuffer.html#abacad2af962b5b0d969ad14c0fb2dc83">CircularBuffer</a> (const QList&lt; value_type &gt; &amp;items, int <a class="el" href="classCircularBuffer.html#a59530258197a44c29342291568f427bf">capacity</a>=-1)</td></tr>
<tr class="memdesc:abacad2af962b5b0d969ad14c0fb2dc83"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor of the <a class="el" href="classCircularBuffer.html" title="A template class that implements a circular or ring buffer.">CircularBuffer</a>.  <a href="classCircularBuffer.html#abacad2af962b5b0d969ad14c0fb2dc83">More...</a><br /></td></tr>
<tr class="separator:abacad2af962b5b0d969ad14c0fb2dc83"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2e3c4727a8fb2ad8cc48a2b9d9bbe48"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCircularBuffer.html#ae2e3c4727a8fb2ad8cc48a2b9d9bbe48">CircularBuffer</a> (const QVector&lt; value_type &gt; &amp;items, int <a class="el" href="classCircularBuffer.html#a59530258197a44c29342291568f427bf">capacity</a>=-1)</td></tr>
<tr class="memdesc:ae2e3c4727a8fb2ad8cc48a2b9d9bbe48"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor of the <a class="el" href="classCircularBuffer.html" title="A template class that implements a circular or ring buffer.">CircularBuffer</a>.  <a href="classCircularBuffer.html#ae2e3c4727a8fb2ad8cc48a2b9d9bbe48">More...</a><br /></td></tr>
<tr class="separator:ae2e3c4727a8fb2ad8cc48a2b9d9bbe48"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2217da374388fdefffff2e91b6f325ce"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCircularBuffer.html#a2217da374388fdefffff2e91b6f325ce">CircularBuffer</a> (const <a class="el" href="classCircularBuffer.html">CircularBuffer</a>&lt; value_type &gt; &amp;other)</td></tr>
<tr class="memdesc:a2217da374388fdefffff2e91b6f325ce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a copy of other.  <a href="classCircularBuffer.html#a2217da374388fdefffff2e91b6f325ce">More...</a><br /></td></tr>
<tr class="separator:a2217da374388fdefffff2e91b6f325ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b89607fa7a2e28ea69dbcf44ede6996"><td class="memItemLeft" align="right" valign="top"><a id="a9b89607fa7a2e28ea69dbcf44ede6996"></a>
iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCircularBuffer.html#a9b89607fa7a2e28ea69dbcf44ede6996">begin</a> ()</td></tr>
<tr class="memdesc:a9b89607fa7a2e28ea69dbcf44ede6996"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an STL-style iterator pointing to the first item in the vector. <br /></td></tr>
<tr class="separator:a9b89607fa7a2e28ea69dbcf44ede6996"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40aceb6e8fecead7298e363dbb867a9e"><td class="memItemLeft" align="right" valign="top"><a id="a40aceb6e8fecead7298e363dbb867a9e"></a>
const_iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCircularBuffer.html#a40aceb6e8fecead7298e363dbb867a9e">begin</a> () const</td></tr>
<tr class="memdesc:a40aceb6e8fecead7298e363dbb867a9e"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded function. <br /></td></tr>
<tr class="separator:a40aceb6e8fecead7298e363dbb867a9e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd7a49179bd7b00d660db479a131b489"><td class="memItemLeft" align="right" valign="top"><a id="abd7a49179bd7b00d660db479a131b489"></a>
const_iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCircularBuffer.html#abd7a49179bd7b00d660db479a131b489">cbegin</a> () const</td></tr>
<tr class="memdesc:abd7a49179bd7b00d660db479a131b489"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an constant STL-style iterator pointing to the first item in the vector. <br /></td></tr>
<tr class="separator:abd7a49179bd7b00d660db479a131b489"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad6c827cbb0d4dfd800a8642818a657be"><td class="memItemLeft" align="right" valign="top"><a id="ad6c827cbb0d4dfd800a8642818a657be"></a>
const_iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCircularBuffer.html#ad6c827cbb0d4dfd800a8642818a657be">constBegin</a> () const</td></tr>
<tr class="memdesc:ad6c827cbb0d4dfd800a8642818a657be"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an constant STL-style iterator pointing to the first item in the vector. <br /></td></tr>
<tr class="separator:ad6c827cbb0d4dfd800a8642818a657be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00ea98e112e1a796e289b1f919aa636c"><td class="memItemLeft" align="right" valign="top"><a id="a00ea98e112e1a796e289b1f919aa636c"></a>
iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCircularBuffer.html#a00ea98e112e1a796e289b1f919aa636c">end</a> ()</td></tr>
<tr class="memdesc:a00ea98e112e1a796e289b1f919aa636c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an STL-style iterator pointing to the last item in the vector. <br /></td></tr>
<tr class="separator:a00ea98e112e1a796e289b1f919aa636c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa0155d87e6abc9e4fdeef79522c0f8df"><td class="memItemLeft" align="right" valign="top"><a id="aa0155d87e6abc9e4fdeef79522c0f8df"></a>
const_iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCircularBuffer.html#aa0155d87e6abc9e4fdeef79522c0f8df">end</a> () const noexcept</td></tr>
<tr class="memdesc:aa0155d87e6abc9e4fdeef79522c0f8df"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an constant STL-style iterator pointing to the last item in the vector. <br /></td></tr>
<tr class="separator:aa0155d87e6abc9e4fdeef79522c0f8df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b594bd84e8ce7866c17af5ced3a8f1d"><td class="memItemLeft" align="right" valign="top"><a id="a2b594bd84e8ce7866c17af5ced3a8f1d"></a>
const_iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCircularBuffer.html#a2b594bd84e8ce7866c17af5ced3a8f1d">cend</a> () const noexcept</td></tr>
<tr class="memdesc:a2b594bd84e8ce7866c17af5ced3a8f1d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an constant STL-style iterator pointing to the last item in the vector. <br /></td></tr>
<tr class="separator:a2b594bd84e8ce7866c17af5ced3a8f1d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7dda4abbb4c6cb1b0f340672d412b4cc"><td class="memItemLeft" align="right" valign="top"><a id="a7dda4abbb4c6cb1b0f340672d412b4cc"></a>
const_iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCircularBuffer.html#a7dda4abbb4c6cb1b0f340672d412b4cc">constEnd</a> () const noexcept</td></tr>
<tr class="memdesc:a7dda4abbb4c6cb1b0f340672d412b4cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a const STL-style iterator pointing to the imaginary item after the last item in the <a class="el" href="classCircularBuffer.html" title="A template class that implements a circular or ring buffer.">CircularBuffer</a>. <br /></td></tr>
<tr class="separator:a7dda4abbb4c6cb1b0f340672d412b4cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a83dd285d4977d731b133671e5878b39b"><td class="memItemLeft" align="right" valign="top"><a id="a83dd285d4977d731b133671e5878b39b"></a>
reverse_iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCircularBuffer.html#a83dd285d4977d731b133671e5878b39b">rbegin</a> ()</td></tr>
<tr class="memdesc:a83dd285d4977d731b133671e5878b39b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a STL-style reverse iterator pointing to the first item in the vector, in reverse order. <br /></td></tr>
<tr class="separator:a83dd285d4977d731b133671e5878b39b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2112d8ce0cacbd66d1720b5bbde2e2c"><td class="memItemLeft" align="right" valign="top"><a id="ae2112d8ce0cacbd66d1720b5bbde2e2c"></a>
reverse_iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCircularBuffer.html#ae2112d8ce0cacbd66d1720b5bbde2e2c">rend</a> ()</td></tr>
<tr class="memdesc:ae2112d8ce0cacbd66d1720b5bbde2e2c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a STL-style reverse iterator pointing to the last item in the vector, in reverse order. <br /></td></tr>
<tr class="separator:ae2112d8ce0cacbd66d1720b5bbde2e2c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5d61c6b00cdcda6fd2db5bbc9acbd79"><td class="memItemLeft" align="right" valign="top"><a id="ae5d61c6b00cdcda6fd2db5bbc9acbd79"></a>
const_reverse_iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCircularBuffer.html#ae5d61c6b00cdcda6fd2db5bbc9acbd79">rbegin</a> () const</td></tr>
<tr class="memdesc:ae5d61c6b00cdcda6fd2db5bbc9acbd79"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a const STL-style reverse iterator pointing to the first item in the vector, in reverse order. <br /></td></tr>
<tr class="separator:ae5d61c6b00cdcda6fd2db5bbc9acbd79"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4ca83491768aaaf02280b509c49029b"><td class="memItemLeft" align="right" valign="top"><a id="af4ca83491768aaaf02280b509c49029b"></a>
const_reverse_iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCircularBuffer.html#af4ca83491768aaaf02280b509c49029b">rend</a> () const</td></tr>
<tr class="memdesc:af4ca83491768aaaf02280b509c49029b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a constant STL-style reverse iterator pointing to the last item in the vector, in reverse order. <br /></td></tr>
<tr class="separator:af4ca83491768aaaf02280b509c49029b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d061b98913ff530ee31331f866f2042"><td class="memItemLeft" align="right" valign="top"><a id="a3d061b98913ff530ee31331f866f2042"></a>
const_reverse_iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCircularBuffer.html#a3d061b98913ff530ee31331f866f2042">crbegin</a> () const</td></tr>
<tr class="memdesc:a3d061b98913ff530ee31331f866f2042"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a const STL-style reverse iterator pointing to the first item in the vector, in reverse order. <br /></td></tr>
<tr class="separator:a3d061b98913ff530ee31331f866f2042"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd95a773bc0bd8d4ccbb3e914abca5e3"><td class="memItemLeft" align="right" valign="top"><a id="acd95a773bc0bd8d4ccbb3e914abca5e3"></a>
const_reverse_iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCircularBuffer.html#acd95a773bc0bd8d4ccbb3e914abca5e3">crend</a> () const</td></tr>
<tr class="memdesc:acd95a773bc0bd8d4ccbb3e914abca5e3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a const STL-style reverse iterator pointing to the last item in the vector, in reverse order. <br /></td></tr>
<tr class="separator:acd95a773bc0bd8d4ccbb3e914abca5e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a81a09a6e0d8567d5b9af9f956bd7be55"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCircularBuffer.html#a81a09a6e0d8567d5b9af9f956bd7be55">pop</a> ()</td></tr>
<tr class="memdesc:a81a09a6e0d8567d5b9af9f956bd7be55"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deletes the first element.  <a href="classCircularBuffer.html#a81a09a6e0d8567d5b9af9f956bd7be55">More...</a><br /></td></tr>
<tr class="separator:a81a09a6e0d8567d5b9af9f956bd7be55"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0a7b658a605d6421c9bb187a5e1f406"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCircularBuffer.html#ae0a7b658a605d6421c9bb187a5e1f406">removeFirst</a> ()</td></tr>
<tr class="memdesc:ae0a7b658a605d6421c9bb187a5e1f406"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deletes the first element.  <a href="classCircularBuffer.html#ae0a7b658a605d6421c9bb187a5e1f406">More...</a><br /></td></tr>
<tr class="separator:ae0a7b658a605d6421c9bb187a5e1f406"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abde089c9e08735367fb80783be334780"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCircularBuffer.html#abde089c9e08735367fb80783be334780">pop_front</a> ()</td></tr>
<tr class="memdesc:abde089c9e08735367fb80783be334780"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deletes the first element.  <a href="classCircularBuffer.html#abde089c9e08735367fb80783be334780">More...</a><br /></td></tr>
<tr class="separator:abde089c9e08735367fb80783be334780"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef1791c6160fe8daa0d84c4788a4bbc4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCircularBuffer.html#aef1791c6160fe8daa0d84c4788a4bbc4">popFront</a> ()</td></tr>
<tr class="memdesc:aef1791c6160fe8daa0d84c4788a4bbc4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deletes the first element.  <a href="classCircularBuffer.html#aef1791c6160fe8daa0d84c4788a4bbc4">More...</a><br /></td></tr>
<tr class="separator:aef1791c6160fe8daa0d84c4788a4bbc4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ca2994bd5cce14dc72ecd1d5bb40fdc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCircularBuffer.html#a3ca2994bd5cce14dc72ecd1d5bb40fdc">popFirst</a> ()</td></tr>
<tr class="memdesc:a3ca2994bd5cce14dc72ecd1d5bb40fdc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deletes the first element.  <a href="classCircularBuffer.html#a3ca2994bd5cce14dc72ecd1d5bb40fdc">More...</a><br /></td></tr>
<tr class="separator:a3ca2994bd5cce14dc72ecd1d5bb40fdc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5da153a3f7c33b972f4f91694813c97"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCircularBuffer.html#ab5da153a3f7c33b972f4f91694813c97">push</a> (const value_type &amp;<a class="el" href="classCircularBuffer.html#ab49b0c13f2a4af3efbddf5832614d6a0">value</a>)</td></tr>
<tr class="memdesc:ab5da153a3f7c33b972f4f91694813c97"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pushes a new item at the head position.  <a href="classCircularBuffer.html#ab5da153a3f7c33b972f4f91694813c97">More...</a><br /></td></tr>
<tr class="separator:ab5da153a3f7c33b972f4f91694813c97"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a29b56924fc7cb412ed89e32d8322a508"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCircularBuffer.html#a29b56924fc7cb412ed89e32d8322a508">push_back</a> (const value_type &amp;<a class="el" href="classCircularBuffer.html#ab49b0c13f2a4af3efbddf5832614d6a0">value</a>)</td></tr>
<tr class="memdesc:a29b56924fc7cb412ed89e32d8322a508"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pushes a new item at the head position.  <a href="classCircularBuffer.html#a29b56924fc7cb412ed89e32d8322a508">More...</a><br /></td></tr>
<tr class="separator:a29b56924fc7cb412ed89e32d8322a508"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a3ccbdb781cce2a2799c52af68ecd48"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCircularBuffer.html#a6a3ccbdb781cce2a2799c52af68ecd48">append</a> (const value_type &amp;<a class="el" href="classCircularBuffer.html#ab49b0c13f2a4af3efbddf5832614d6a0">value</a>)</td></tr>
<tr class="memdesc:a6a3ccbdb781cce2a2799c52af68ecd48"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pushes a new item at the head position.  <a href="classCircularBuffer.html#a6a3ccbdb781cce2a2799c52af68ecd48">More...</a><br /></td></tr>
<tr class="separator:a6a3ccbdb781cce2a2799c52af68ecd48"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91f5d316f1fae066fdeb1978155479d7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCircularBuffer.html#a91f5d316f1fae066fdeb1978155479d7">push</a> (const QList&lt; value_type &gt; values)</td></tr>
<tr class="memdesc:a91f5d316f1fae066fdeb1978155479d7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pushes a list of items to the buffer.  <a href="classCircularBuffer.html#a91f5d316f1fae066fdeb1978155479d7">More...</a><br /></td></tr>
<tr class="separator:a91f5d316f1fae066fdeb1978155479d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01434fe991daa3020e26aa290bf37aaf"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCircularBuffer.html#a01434fe991daa3020e26aa290bf37aaf">append</a> (const QList&lt; value_type &gt; values)</td></tr>
<tr class="memdesc:a01434fe991daa3020e26aa290bf37aaf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pushes a new item at the head position.  <a href="classCircularBuffer.html#a01434fe991daa3020e26aa290bf37aaf">More...</a><br /></td></tr>
<tr class="separator:a01434fe991daa3020e26aa290bf37aaf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9305ca519cd0d7bc850298709d2d043e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCircularBuffer.html#a9305ca519cd0d7bc850298709d2d043e">push</a> (const QVector&lt; value_type &gt; &amp;values)</td></tr>
<tr class="memdesc:a9305ca519cd0d7bc850298709d2d043e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pushes a vector of items to the buffer.  <a href="classCircularBuffer.html#a9305ca519cd0d7bc850298709d2d043e">More...</a><br /></td></tr>
<tr class="separator:a9305ca519cd0d7bc850298709d2d043e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac084fd3bc6096ea544950508ef5c949e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCircularBuffer.html#ac084fd3bc6096ea544950508ef5c949e">append</a> (const QVector&lt; value_type &gt; &amp;values)</td></tr>
<tr class="memdesc:ac084fd3bc6096ea544950508ef5c949e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pushes a vector of items to the buffer.  <a href="classCircularBuffer.html#ac084fd3bc6096ea544950508ef5c949e">More...</a><br /></td></tr>
<tr class="separator:ac084fd3bc6096ea544950508ef5c949e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ccd41c830b60c72a1d8605fecde67e5"><td class="memItemLeft" align="right" valign="top">const value_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCircularBuffer.html#a2ccd41c830b60c72a1d8605fecde67e5">get</a> ()</td></tr>
<tr class="memdesc:a2ccd41c830b60c72a1d8605fecde67e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">pulls an item from the front position and returns it.  <a href="classCircularBuffer.html#a2ccd41c830b60c72a1d8605fecde67e5">More...</a><br /></td></tr>
<tr class="separator:a2ccd41c830b60c72a1d8605fecde67e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88ce5231f66d39548844703f93cd4bf9"><td class="memItemLeft" align="right" valign="top">const value_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCircularBuffer.html#a88ce5231f66d39548844703f93cd4bf9">takeFirst</a> ()</td></tr>
<tr class="memdesc:a88ce5231f66d39548844703f93cd4bf9"><td class="mdescLeft">&#160;</td><td class="mdescRight">pulls an item from the front position and returns it.  <a href="classCircularBuffer.html#a88ce5231f66d39548844703f93cd4bf9">More...</a><br /></td></tr>
<tr class="separator:a88ce5231f66d39548844703f93cd4bf9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a28e14174200a3d99e53da805da70d003"><td class="memItemLeft" align="right" valign="top">const value_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCircularBuffer.html#a28e14174200a3d99e53da805da70d003">takeFront</a> ()</td></tr>
<tr class="memdesc:a28e14174200a3d99e53da805da70d003"><td class="mdescLeft">&#160;</td><td class="mdescRight">pulls an item from the front position and returns it.  <a href="classCircularBuffer.html#a28e14174200a3d99e53da805da70d003">More...</a><br /></td></tr>
<tr class="separator:a28e14174200a3d99e53da805da70d003"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a090c9c6ec8f544fd19c2b6a0055c1805"><td class="memItemLeft" align="right" valign="top">const QVector&lt; value_type &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCircularBuffer.html#a090c9c6ec8f544fd19c2b6a0055c1805">get</a> (int <a class="el" href="classCircularBuffer.html#a6ec5132660c3a9c41f6c0584e74c4a8b">count</a>)</td></tr>
<tr class="memdesc:a090c9c6ec8f544fd19c2b6a0055c1805"><td class="mdescLeft">&#160;</td><td class="mdescRight">pulls an count items from the front position.  <a href="classCircularBuffer.html#a090c9c6ec8f544fd19c2b6a0055c1805">More...</a><br /></td></tr>
<tr class="separator:a090c9c6ec8f544fd19c2b6a0055c1805"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d7cc7952570f9066b2c278f503444cb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCircularBuffer.html#a1d7cc7952570f9066b2c278f503444cb">fill</a> (value_type &amp;<a class="el" href="classCircularBuffer.html#ab49b0c13f2a4af3efbddf5832614d6a0">value</a>, int <a class="el" href="classCircularBuffer.html#a6600179eace34c6de4ae0781246ee0b4">size</a>=-1)</td></tr>
<tr class="memdesc:a1d7cc7952570f9066b2c278f503444cb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assigns value to all, or size, items in the vector.  <a href="classCircularBuffer.html#a1d7cc7952570f9066b2c278f503444cb">More...</a><br /></td></tr>
<tr class="separator:a1d7cc7952570f9066b2c278f503444cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11000942e29ce9625dc35683becef9e0"><td class="memItemLeft" align="right" valign="top">reference&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCircularBuffer.html#a11000942e29ce9625dc35683becef9e0">at</a> (int index)</td></tr>
<tr class="memdesc:a11000942e29ce9625dc35683becef9e0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access the element at index, relative to the tail of the buffer.  <a href="classCircularBuffer.html#a11000942e29ce9625dc35683becef9e0">More...</a><br /></td></tr>
<tr class="separator:a11000942e29ce9625dc35683becef9e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c4dfdd88975c243d17c0d7b623bc03c"><td class="memItemLeft" align="right" valign="top">const_reference&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCircularBuffer.html#a5c4dfdd88975c243d17c0d7b623bc03c">at</a> (int index) const</td></tr>
<tr class="memdesc:a5c4dfdd88975c243d17c0d7b623bc03c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access the element at index, relative to the tail of the buffer.  <a href="classCircularBuffer.html#a5c4dfdd88975c243d17c0d7b623bc03c">More...</a><br /></td></tr>
<tr class="separator:a5c4dfdd88975c243d17c0d7b623bc03c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab49b0c13f2a4af3efbddf5832614d6a0"><td class="memItemLeft" align="right" valign="top">value_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCircularBuffer.html#ab49b0c13f2a4af3efbddf5832614d6a0">value</a> (int index)</td></tr>
<tr class="memdesc:ab49b0c13f2a4af3efbddf5832614d6a0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access the element at index, relative to the tail of the buffer.  <a href="classCircularBuffer.html#ab49b0c13f2a4af3efbddf5832614d6a0">More...</a><br /></td></tr>
<tr class="separator:ab49b0c13f2a4af3efbddf5832614d6a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acadfcf767d3efcfed33d6c08cd8c98c1"><td class="memItemLeft" align="right" valign="top">value_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCircularBuffer.html#acadfcf767d3efcfed33d6c08cd8c98c1">value</a> (int index, const value_type defaultValue)</td></tr>
<tr class="memdesc:acadfcf767d3efcfed33d6c08cd8c98c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access the element at index, relative to the tail of the buffer or a supplied default value.  <a href="classCircularBuffer.html#acadfcf767d3efcfed33d6c08cd8c98c1">More...</a><br /></td></tr>
<tr class="separator:acadfcf767d3efcfed33d6c08cd8c98c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5fc2878ede1b6b8c2612f77a0b4752c5"><td class="memItemLeft" align="right" valign="top">reference&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCircularBuffer.html#a5fc2878ede1b6b8c2612f77a0b4752c5">first</a> ()</td></tr>
<tr class="memdesc:a5fc2878ede1b6b8c2612f77a0b4752c5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access the first element.  <a href="classCircularBuffer.html#a5fc2878ede1b6b8c2612f77a0b4752c5">More...</a><br /></td></tr>
<tr class="separator:a5fc2878ede1b6b8c2612f77a0b4752c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4847cd4379d1ce36055b0cf74ddc4acf"><td class="memItemLeft" align="right" valign="top">const_reference &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCircularBuffer.html#a4847cd4379d1ce36055b0cf74ddc4acf">first</a> () const</td></tr>
<tr class="memdesc:a4847cd4379d1ce36055b0cf74ddc4acf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access the first element.  <a href="classCircularBuffer.html#a4847cd4379d1ce36055b0cf74ddc4acf">More...</a><br /></td></tr>
<tr class="separator:a4847cd4379d1ce36055b0cf74ddc4acf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d3b8caeed73e0384045ba4f4081f15b"><td class="memItemLeft" align="right" valign="top">reference&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCircularBuffer.html#a1d3b8caeed73e0384045ba4f4081f15b">front</a> ()</td></tr>
<tr class="memdesc:a1d3b8caeed73e0384045ba4f4081f15b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access the first element.  <a href="classCircularBuffer.html#a1d3b8caeed73e0384045ba4f4081f15b">More...</a><br /></td></tr>
<tr class="separator:a1d3b8caeed73e0384045ba4f4081f15b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ff6b930a002cef801b4722bb92c762d"><td class="memItemLeft" align="right" valign="top">const_reference&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCircularBuffer.html#a6ff6b930a002cef801b4722bb92c762d">front</a> () const</td></tr>
<tr class="memdesc:a6ff6b930a002cef801b4722bb92c762d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access the first element.  <a href="classCircularBuffer.html#a6ff6b930a002cef801b4722bb92c762d">More...</a><br /></td></tr>
<tr class="separator:a6ff6b930a002cef801b4722bb92c762d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a926ea46b3d459ec32db2a420d7b5a640"><td class="memItemLeft" align="right" valign="top">const_reference &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCircularBuffer.html#a926ea46b3d459ec32db2a420d7b5a640">constFirst</a> () const</td></tr>
<tr class="memdesc:a926ea46b3d459ec32db2a420d7b5a640"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access the first element.  <a href="classCircularBuffer.html#a926ea46b3d459ec32db2a420d7b5a640">More...</a><br /></td></tr>
<tr class="separator:a926ea46b3d459ec32db2a420d7b5a640"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:affcb65586740b7873cd7c91467aa98fa"><td class="memItemLeft" align="right" valign="top">const_reference &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCircularBuffer.html#affcb65586740b7873cd7c91467aa98fa">constFront</a> () const</td></tr>
<tr class="memdesc:affcb65586740b7873cd7c91467aa98fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access the first element.  <a href="classCircularBuffer.html#affcb65586740b7873cd7c91467aa98fa">More...</a><br /></td></tr>
<tr class="separator:affcb65586740b7873cd7c91467aa98fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a73b27a250169aea48f03a3187de6f238"><td class="memItemLeft" align="right" valign="top">reference&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCircularBuffer.html#a73b27a250169aea48f03a3187de6f238">back</a> ()</td></tr>
<tr class="memdesc:a73b27a250169aea48f03a3187de6f238"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access the last element.  <a href="classCircularBuffer.html#a73b27a250169aea48f03a3187de6f238">More...</a><br /></td></tr>
<tr class="separator:a73b27a250169aea48f03a3187de6f238"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc9dfa40c186a050982259c2493a1286"><td class="memItemLeft" align="right" valign="top">const_reference&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCircularBuffer.html#abc9dfa40c186a050982259c2493a1286">back</a> () const</td></tr>
<tr class="memdesc:abc9dfa40c186a050982259c2493a1286"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access the last element.  <a href="classCircularBuffer.html#abc9dfa40c186a050982259c2493a1286">More...</a><br /></td></tr>
<tr class="separator:abc9dfa40c186a050982259c2493a1286"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e91cf81442adb22e413e2d1ec0d6177"><td class="memItemLeft" align="right" valign="top">reference&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCircularBuffer.html#a0e91cf81442adb22e413e2d1ec0d6177">last</a> ()</td></tr>
<tr class="memdesc:a0e91cf81442adb22e413e2d1ec0d6177"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access the last element.  <a href="classCircularBuffer.html#a0e91cf81442adb22e413e2d1ec0d6177">More...</a><br /></td></tr>
<tr class="separator:a0e91cf81442adb22e413e2d1ec0d6177"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab56ae7118e07ac69180e26f1f6b44cb3"><td class="memItemLeft" align="right" valign="top">const_reference&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCircularBuffer.html#ab56ae7118e07ac69180e26f1f6b44cb3">last</a> () const</td></tr>
<tr class="memdesc:ab56ae7118e07ac69180e26f1f6b44cb3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access the last element.  <a href="classCircularBuffer.html#ab56ae7118e07ac69180e26f1f6b44cb3">More...</a><br /></td></tr>
<tr class="separator:ab56ae7118e07ac69180e26f1f6b44cb3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab50bbd5c853bdae84d201e95cfbc1dcd"><td class="memItemLeft" align="right" valign="top">const_reference&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCircularBuffer.html#ab50bbd5c853bdae84d201e95cfbc1dcd">constLast</a> () const</td></tr>
<tr class="memdesc:ab50bbd5c853bdae84d201e95cfbc1dcd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access the last element.  <a href="classCircularBuffer.html#ab50bbd5c853bdae84d201e95cfbc1dcd">More...</a><br /></td></tr>
<tr class="separator:ab50bbd5c853bdae84d201e95cfbc1dcd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2f7f8e6edc9189b8938222776bcbe68"><td class="memItemLeft" align="right" valign="top">const QVector&lt; value_type &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCircularBuffer.html#ad2f7f8e6edc9189b8938222776bcbe68">toVector</a> ()</td></tr>
<tr class="memdesc:ad2f7f8e6edc9189b8938222776bcbe68"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access the data as a QVector.  <a href="classCircularBuffer.html#ad2f7f8e6edc9189b8938222776bcbe68">More...</a><br /></td></tr>
<tr class="separator:ad2f7f8e6edc9189b8938222776bcbe68"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae21ff905f06a74db2dce6bc3527ec4d3"><td class="memItemLeft" align="right" valign="top">const QVector&lt; value_type &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCircularBuffer.html#ae21ff905f06a74db2dce6bc3527ec4d3">pullVector</a> ()</td></tr>
<tr class="memdesc:ae21ff905f06a74db2dce6bc3527ec4d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access the data as a QVector, emptying the buffer.  <a href="classCircularBuffer.html#ae21ff905f06a74db2dce6bc3527ec4d3">More...</a><br /></td></tr>
<tr class="separator:ae21ff905f06a74db2dce6bc3527ec4d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a69996ee0803ab3543f4904d4fc5c9985"><td class="memItemLeft" align="right" valign="top">const std::vector&lt; value_type &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCircularBuffer.html#a69996ee0803ab3543f4904d4fc5c9985">toStdVector</a> ()</td></tr>
<tr class="memdesc:a69996ee0803ab3543f4904d4fc5c9985"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access the data as a std::vector.  <a href="classCircularBuffer.html#a69996ee0803ab3543f4904d4fc5c9985">More...</a><br /></td></tr>
<tr class="separator:a69996ee0803ab3543f4904d4fc5c9985"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb0282ed740c6dd8f58e5645d3670836"><td class="memItemLeft" align="right" valign="top">const std::vector&lt; value_type &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCircularBuffer.html#adb0282ed740c6dd8f58e5645d3670836">pullStdVector</a> ()</td></tr>
<tr class="memdesc:adb0282ed740c6dd8f58e5645d3670836"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access the data as a std::vector.  <a href="classCircularBuffer.html#adb0282ed740c6dd8f58e5645d3670836">More...</a><br /></td></tr>
<tr class="separator:adb0282ed740c6dd8f58e5645d3670836"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4edf2083cb71ee06c6249cf0f486f83"><td class="memItemLeft" align="right" valign="top">const QList&lt; value_type &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCircularBuffer.html#ab4edf2083cb71ee06c6249cf0f486f83">toList</a> ()</td></tr>
<tr class="memdesc:ab4edf2083cb71ee06c6249cf0f486f83"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access the data as a QList.  <a href="classCircularBuffer.html#ab4edf2083cb71ee06c6249cf0f486f83">More...</a><br /></td></tr>
<tr class="separator:ab4edf2083cb71ee06c6249cf0f486f83"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63a93aa0b1a6e6c14a2180ecb9be231b"><td class="memItemLeft" align="right" valign="top">const QList&lt; value_type &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCircularBuffer.html#a63a93aa0b1a6e6c14a2180ecb9be231b">pullList</a> ()</td></tr>
<tr class="memdesc:a63a93aa0b1a6e6c14a2180ecb9be231b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access the data as a QList.  <a href="classCircularBuffer.html#a63a93aa0b1a6e6c14a2180ecb9be231b">More...</a><br /></td></tr>
<tr class="separator:a63a93aa0b1a6e6c14a2180ecb9be231b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a56ffb6a42f0377c2ada4b2ff03db23a3"><td class="memItemLeft" align="right" valign="top">const std::list&lt; value_type &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCircularBuffer.html#a56ffb6a42f0377c2ada4b2ff03db23a3">toStdList</a> ()</td></tr>
<tr class="memdesc:a56ffb6a42f0377c2ada4b2ff03db23a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access the data as a std::list.  <a href="classCircularBuffer.html#a56ffb6a42f0377c2ada4b2ff03db23a3">More...</a><br /></td></tr>
<tr class="separator:a56ffb6a42f0377c2ada4b2ff03db23a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ad8aece5983ba783632a7daf2ccad22"><td class="memItemLeft" align="right" valign="top">const std::list&lt; value_type &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCircularBuffer.html#a0ad8aece5983ba783632a7daf2ccad22">pullStdList</a> ()</td></tr>
<tr class="memdesc:a0ad8aece5983ba783632a7daf2ccad22"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access the data as a QList.  <a href="classCircularBuffer.html#a0ad8aece5983ba783632a7daf2ccad22">More...</a><br /></td></tr>
<tr class="separator:a0ad8aece5983ba783632a7daf2ccad22"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6600179eace34c6de4ae0781246ee0b4"><td class="memItemLeft" align="right" valign="top"><a id="a6600179eace34c6de4ae0781246ee0b4"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCircularBuffer.html#a6600179eace34c6de4ae0781246ee0b4">size</a> () const</td></tr>
<tr class="memdesc:a6600179eace34c6de4ae0781246ee0b4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of items stored in the buffer. <br /></td></tr>
<tr class="separator:a6600179eace34c6de4ae0781246ee0b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ec5132660c3a9c41f6c0584e74c4a8b"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCircularBuffer.html#a6ec5132660c3a9c41f6c0584e74c4a8b">count</a> () const</td></tr>
<tr class="memdesc:a6ec5132660c3a9c41f6c0584e74c4a8b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of items stored in the buffer.  <a href="classCircularBuffer.html#a6ec5132660c3a9c41f6c0584e74c4a8b">More...</a><br /></td></tr>
<tr class="separator:a6ec5132660c3a9c41f6c0584e74c4a8b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0e3d8da20b284f9159309e6e4d60273"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCircularBuffer.html#ac0e3d8da20b284f9159309e6e4d60273">length</a> () const</td></tr>
<tr class="memdesc:ac0e3d8da20b284f9159309e6e4d60273"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of items stored in the buffer.  <a href="classCircularBuffer.html#ac0e3d8da20b284f9159309e6e4d60273">More...</a><br /></td></tr>
<tr class="separator:ac0e3d8da20b284f9159309e6e4d60273"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59530258197a44c29342291568f427bf"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCircularBuffer.html#a59530258197a44c29342291568f427bf">capacity</a> () const</td></tr>
<tr class="memdesc:a59530258197a44c29342291568f427bf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the total capacity of the buffer.  <a href="classCircularBuffer.html#a59530258197a44c29342291568f427bf">More...</a><br /></td></tr>
<tr class="separator:a59530258197a44c29342291568f427bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af52a24e18b39e92fa36b7c48b1feaadf"><td class="memItemLeft" align="right" valign="top"><a id="af52a24e18b39e92fa36b7c48b1feaadf"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCircularBuffer.html#af52a24e18b39e92fa36b7c48b1feaadf">available</a> () const</td></tr>
<tr class="memdesc:af52a24e18b39e92fa36b7c48b1feaadf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the total free space still available to the buffer. <br /></td></tr>
<tr class="separator:af52a24e18b39e92fa36b7c48b1feaadf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2078a5f761bbe226681a422b1f35d0bb"><td class="memItemLeft" align="right" valign="top"><a id="a2078a5f761bbe226681a422b1f35d0bb"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCircularBuffer.html#a2078a5f761bbe226681a422b1f35d0bb">empty</a> () const</td></tr>
<tr class="memdesc:a2078a5f761bbe226681a422b1f35d0bb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the buffer is empty. <br /></td></tr>
<tr class="separator:a2078a5f761bbe226681a422b1f35d0bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3981716c7fd8d014a02fafd6b3db1e62"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCircularBuffer.html#a3981716c7fd8d014a02fafd6b3db1e62">isEmpty</a> () const</td></tr>
<tr class="memdesc:a3981716c7fd8d014a02fafd6b3db1e62"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the buffer is empty.  <a href="classCircularBuffer.html#a3981716c7fd8d014a02fafd6b3db1e62">More...</a><br /></td></tr>
<tr class="separator:a3981716c7fd8d014a02fafd6b3db1e62"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c6bc2d47789b7a5d1b61b65b18df9a2"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCircularBuffer.html#a6c6bc2d47789b7a5d1b61b65b18df9a2">isFull</a> () const</td></tr>
<tr class="memdesc:a6c6bc2d47789b7a5d1b61b65b18df9a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the buffer is full.  <a href="classCircularBuffer.html#a6c6bc2d47789b7a5d1b61b65b18df9a2">More...</a><br /></td></tr>
<tr class="separator:a6c6bc2d47789b7a5d1b61b65b18df9a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a60c780f5d1b46d7519e057d65ea8be8e"><td class="memItemLeft" align="right" valign="top"><a id="a60c780f5d1b46d7519e057d65ea8be8e"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCircularBuffer.html#a60c780f5d1b46d7519e057d65ea8be8e">clear</a> ()</td></tr>
<tr class="memdesc:a60c780f5d1b46d7519e057d65ea8be8e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes all the elements from the vector. <br /></td></tr>
<tr class="separator:a60c780f5d1b46d7519e057d65ea8be8e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd0bd3ff763b344c9a9c514dd044f32c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCircularBuffer.html#abd0bd3ff763b344c9a9c514dd044f32c">reserve</a> (const int <a class="el" href="classCircularBuffer.html#a59530258197a44c29342291568f427bf">capacity</a>)</td></tr>
<tr class="memdesc:abd0bd3ff763b344c9a9c514dd044f32c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resizes the buffer to a new capacity.  <a href="classCircularBuffer.html#abd0bd3ff763b344c9a9c514dd044f32c">More...</a><br /></td></tr>
<tr class="separator:abd0bd3ff763b344c9a9c514dd044f32c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a03a4250a22aeb8777ee17fa192d8ac36"><td class="memItemLeft" align="right" valign="top">reference&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCircularBuffer.html#a03a4250a22aeb8777ee17fa192d8ac36">operator[]</a> (int index)</td></tr>
<tr class="memdesc:a03a4250a22aeb8777ee17fa192d8ac36"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the value at the index, relative to the tail of the buffer.  <a href="classCircularBuffer.html#a03a4250a22aeb8777ee17fa192d8ac36">More...</a><br /></td></tr>
<tr class="separator:a03a4250a22aeb8777ee17fa192d8ac36"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a29fff81d518245ded92a4d1f433e3778"><td class="memItemLeft" align="right" valign="top">const_reference&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCircularBuffer.html#a29fff81d518245ded92a4d1f433e3778">operator[]</a> (int index) const</td></tr>
<tr class="memdesc:a29fff81d518245ded92a4d1f433e3778"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the value at the index, relative to the tail of the buffer.  <a href="classCircularBuffer.html#a29fff81d518245ded92a4d1f433e3778">More...</a><br /></td></tr>
<tr class="separator:a29fff81d518245ded92a4d1f433e3778"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4b86c094e83d3b9efe903dc65954298"><td class="memItemLeft" align="right" valign="top"><a id="ab4b86c094e83d3b9efe903dc65954298"></a>
<a class="el" href="classCircularBuffer.html">CircularBuffer</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCircularBuffer.html#ab4b86c094e83d3b9efe903dc65954298">operator=</a> (self_type &amp;other)</td></tr>
<tr class="memdesc:ab4b86c094e83d3b9efe903dc65954298"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assigns other to this buffer and returns a reference to this buffer. <br /></td></tr>
<tr class="separator:ab4b86c094e83d3b9efe903dc65954298"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af11d51fe9b91080b8388395324cb4db2"><td class="memItemLeft" align="right" valign="top"><a id="af11d51fe9b91080b8388395324cb4db2"></a>
<a class="el" href="classCircularBuffer.html">CircularBuffer</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCircularBuffer.html#af11d51fe9b91080b8388395324cb4db2">operator=</a> (const self_type &amp;other)</td></tr>
<tr class="memdesc:af11d51fe9b91080b8388395324cb4db2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assigns other to this buffer and returns a reference to this buffer. <br /></td></tr>
<tr class="separator:af11d51fe9b91080b8388395324cb4db2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa9afaff501c953375a85cf634a27f3c1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classCircularBuffer.html">CircularBuffer</a>&lt; value_type &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCircularBuffer.html#aa9afaff501c953375a85cf634a27f3c1">operator&lt;&lt;</a> (const value_type <a class="el" href="classCircularBuffer.html#ab49b0c13f2a4af3efbddf5832614d6a0">value</a>)</td></tr>
<tr class="memdesc:aa9afaff501c953375a85cf634a27f3c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pushes a new item at the head position.  <a href="classCircularBuffer.html#aa9afaff501c953375a85cf634a27f3c1">More...</a><br /></td></tr>
<tr class="separator:aa9afaff501c953375a85cf634a27f3c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab3a94923b0319035036187a63ce4e760"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classCircularBuffer.html">CircularBuffer</a>&lt; value_type &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCircularBuffer.html#ab3a94923b0319035036187a63ce4e760">operator&lt;&lt;</a> (const QVector&lt; value_type &gt; &amp;other)</td></tr>
<tr class="memdesc:ab3a94923b0319035036187a63ce4e760"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pushes a vector of items to the buffer.  <a href="classCircularBuffer.html#ab3a94923b0319035036187a63ce4e760">More...</a><br /></td></tr>
<tr class="separator:ab3a94923b0319035036187a63ce4e760"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a563e9dca98c880f12c8ba0ddbd5eccbd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classCircularBuffer.html">CircularBuffer</a>&lt; value_type &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCircularBuffer.html#a563e9dca98c880f12c8ba0ddbd5eccbd">operator&lt;&lt;</a> (const QList&lt; value_type &gt; &amp;other)</td></tr>
<tr class="memdesc:a563e9dca98c880f12c8ba0ddbd5eccbd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pushes a list of items to the buffer.  <a href="classCircularBuffer.html#a563e9dca98c880f12c8ba0ddbd5eccbd">More...</a><br /></td></tr>
<tr class="separator:a563e9dca98c880f12c8ba0ddbd5eccbd"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;typename T, bool always_accept_data_when_full = true, typename Alloc = std::allocator&lt;T&gt;&gt;<br />
class CircularBuffer&lt; T, always_accept_data_when_full, Alloc &gt;</h3>

<p>A template class that implements a circular or ring buffer. </p>
<dl class="section since"><dt>Since</dt><dd>5.14.0</dd></dl>
<p><a class="el" href="classCircularBuffer.html" title="A template class that implements a circular or ring buffer.">CircularBuffer</a> works basically like a queue with items pushed to the head of the buffer and pulled from the tail. Unlike a queue however, when the buffer is full the items overwrite the oldest data and the <a class="el" href="classCircularBuffer.html" title="A template class that implements a circular or ring buffer.">CircularBuffer</a> is NOT resized.</p>
<p>The primary constructor, <a class="el" href="classCircularBuffer.html#ab5b3c8de70e924bdec71dc915365e260" title="Constructor of the CircularBuffer.">CircularBuffer(int)</a> which initialises a buffer with a supplied capacity but a size of 0. Alternatively you can initialise the buffer using either a QList&lt;value_type&gt; or a QVector&lt;value_type&gt;, either directly which creates a buffer with a capacity the same size as the supplied item, or with a supplied int capacity which will will set the capacity accordingly. Please note that if the capcity set is smaller than the supplied list/vector then only the last N items will be retained.</p>
<p>It is also possible to <a class="el" href="classCircularBuffer.html#ab5da153a3f7c33b972f4f91694813c97" title="Pushes a new item at the head position.">push()</a> a QList or a QVector of items onto the buffer, or alternatively use CircularBuffer::iterator which are basically a typedef of std::iterator. <a class="el" href="classCircularBuffer.html" title="A template class that implements a circular or ring buffer.">CircularBuffer</a> has a <a class="el" href="classCircularBuffer.html#a9b89607fa7a2e28ea69dbcf44ede6996" title="Returns an STL-style iterator pointing to the first item in the vector.">begin()</a> and <a class="el" href="classCircularBuffer.html#a00ea98e112e1a796e289b1f919aa636c" title="Returns an STL-style iterator pointing to the last item in the vector.">end()</a> iterator, also <a class="el" href="classCircularBuffer.html#abd7a49179bd7b00d660db479a131b489" title="Returns an constant STL-style iterator pointing to the first item in the vector.">cbegin()</a>, <a class="el" href="classCircularBuffer.html#a2b594bd84e8ce7866c17af5ced3a8f1d" title="Returns an constant STL-style iterator pointing to the last item in the vector.">cend()</a>, <a class="el" href="classCircularBuffer.html#ad6c827cbb0d4dfd800a8642818a657be" title="Returns an constant STL-style iterator pointing to the first item in the vector.">constBegin()</a>, <a class="el" href="classCircularBuffer.html#a7dda4abbb4c6cb1b0f340672d412b4cc" title="Returns a const STL-style iterator pointing to the imaginary item after the last item in the Circular...">constEnd()</a>, <a class="el" href="classCircularBuffer.html#a83dd285d4977d731b133671e5878b39b" title="Returns a STL-style reverse iterator pointing to the first item in the vector, in reverse order.">rbegin()</a> and <a class="el" href="classCircularBuffer.html#ae2112d8ce0cacbd66d1720b5bbde2e2c" title="Returns a STL-style reverse iterator pointing to the last item in the vector, in reverse order.">rend()</a> in exactly the same way as QVector, which makes sense as the underlying class to <a class="el" href="classCircularBuffer.html" title="A template class that implements a circular or ring buffer.">CircularBuffer</a> is a QVector(). A further option is to push items using the <a class="el" href="classCircularBuffer.html#aa9afaff501c953375a85cf634a27f3c1" title="Pushes a new item at the head position.">operator&lt;&lt;()</a> which allows the pushing of a single item of type T, or alternatively a QVector&lt;value_type&gt; or a QList&lt;value_type&gt;.</p>
<p>The earliest item on the buffer can be accessed and removed using the pull() method. Alternatively you can pull more than one item by calling pull(count) which pulls either 'count' items or <a class="el" href="classCircularBuffer.html#a6600179eace34c6de4ae0781246ee0b4" title="Returns the number of items stored in the buffer.">size()</a> items whichever is smaller. The <a class="el" href="classCircularBuffer.html#ad2f7f8e6edc9189b8938222776bcbe68" title="Access the data as a QVector.">toVector()</a>, <a class="el" href="classCircularBuffer.html#ab4edf2083cb71ee06c6249cf0f486f83" title="Access the data as a QList.">toList()</a>, <a class="el" href="classCircularBuffer.html#a69996ee0803ab3543f4904d4fc5c9985" title="Access the data as a std::vector.">toStdVector()</a> and <a class="el" href="classCircularBuffer.html#a56ffb6a42f0377c2ada4b2ff03db23a3" title="Access the data as a std::list.">toStdList()</a> methods can be used to access the entire contents as a QVector&lt;value_type&gt;, a QList&lt;value_type&gt;, a std::vector&lt;value_type&gt; or a std::list&lt;value_type&gt; respectively.</p>
<p>As in most Qt collection classes, there are alternatives to most of the methods: for example <a class="el" href="classCircularBuffer.html#ab5da153a3f7c33b972f4f91694813c97" title="Pushes a new item at the head position.">push()</a>, <a class="el" href="classCircularBuffer.html#a6a3ccbdb781cce2a2799c52af68ecd48" title="Pushes a new item at the head position.">append()</a> or <a class="el" href="classCircularBuffer.html#aa9afaff501c953375a85cf634a27f3c1" title="Pushes a new item at the head position.">operator&lt;&lt;()</a> or <a class="el" href="classCircularBuffer.html#a1d3b8caeed73e0384045ba4f4081f15b" title="Access the first element.">front()</a>, <a class="el" href="classCircularBuffer.html#a5fc2878ede1b6b8c2612f77a0b4752c5" title="Access the first element.">first()</a>. These are mostly supplied to match either historical Qt or STL methods.</p>
<p>You can call <a class="el" href="classCircularBuffer.html#a1d7cc7952570f9066b2c278f503444cb" title="Assigns value to all, or size, items in the vector.">fill()</a> at any time to fill the vector with a particular value.</p>
<p>This is basically just a wrapper around the stl style circular_buffer calls by Peter Goodliffe.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>template type. </td></tr>
  </table>
  </dd>
</dl>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="ab5b3c8de70e924bdec71dc915365e260"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab5b3c8de70e924bdec71dc915365e260">&#9670;&nbsp;</a></span>CircularBuffer() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , bool always_accept_data_when_full = true, typename Alloc  = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classCircularBuffer.html">CircularBuffer</a>&lt; T, always_accept_data_when_full, Alloc &gt;::<a class="el" href="classCircularBuffer.html">CircularBuffer</a> </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>capacity</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructor of the <a class="el" href="classCircularBuffer.html" title="A template class that implements a circular or ring buffer.">CircularBuffer</a>. </p>
<p>Creates a new circular buffer with a capacity of capacity, and fills it with default values of type T.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">capacity</td><td>- an int value specifying how many items may be stored in the buffer. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="abacad2af962b5b0d969ad14c0fb2dc83"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abacad2af962b5b0d969ad14c0fb2dc83">&#9670;&nbsp;</a></span>CircularBuffer() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , bool always_accept_data_when_full = true, typename Alloc  = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classCircularBuffer.html">CircularBuffer</a>&lt; T, always_accept_data_when_full, Alloc &gt;::<a class="el" href="classCircularBuffer.html">CircularBuffer</a> </td>
          <td>(</td>
          <td class="paramtype">const QList&lt; value_type &gt; &amp;&#160;</td>
          <td class="paramname"><em>items</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>capacity</em> = <code>-1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructor of the <a class="el" href="classCircularBuffer.html" title="A template class that implements a circular or ring buffer.">CircularBuffer</a>. </p>
<p>Creates a new circular buffer, using the size and contents of the list, unless the optional capacity is used in which this value is used. If the capcity is less than the size of the supplied QList, only the last N values are stored. Primitive types like int and double, as well as for pointer types, the C++ language doesn't specify any initialization; in those cases, Qt's containers automatically initialize the value to 0.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">items</td><td>- a QList&lt;value_type&gt; containig the items to push. </td></tr>
    <tr><td class="paramname">capacity</td><td>- an optional capacity for the buffer. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae2e3c4727a8fb2ad8cc48a2b9d9bbe48"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae2e3c4727a8fb2ad8cc48a2b9d9bbe48">&#9670;&nbsp;</a></span>CircularBuffer() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , bool always_accept_data_when_full = true, typename Alloc  = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classCircularBuffer.html">CircularBuffer</a>&lt; T, always_accept_data_when_full, Alloc &gt;::<a class="el" href="classCircularBuffer.html">CircularBuffer</a> </td>
          <td>(</td>
          <td class="paramtype">const QVector&lt; value_type &gt; &amp;&#160;</td>
          <td class="paramname"><em>items</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>capacity</em> = <code>-1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructor of the <a class="el" href="classCircularBuffer.html" title="A template class that implements a circular or ring buffer.">CircularBuffer</a>. </p>
<p>Creates a new circular buffer, using the size and contents of the vector, unless the optional capacity is used in which this value is used. If the capacity is less than the size of the supplied QVector, only the last N values are stored.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">items</td><td>- a QVector&lt;value_type&gt; containing the items to push. </td></tr>
    <tr><td class="paramname">capacity</td><td>- an optional capacity for the buffer. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2217da374388fdefffff2e91b6f325ce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2217da374388fdefffff2e91b6f325ce">&#9670;&nbsp;</a></span>CircularBuffer() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , bool always_accept_data_when_full = true, typename Alloc  = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classCircularBuffer.html">CircularBuffer</a>&lt; T, always_accept_data_when_full, Alloc &gt;::<a class="el" href="classCircularBuffer.html">CircularBuffer</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classCircularBuffer.html">CircularBuffer</a>&lt; value_type &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs a copy of other. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>- another <a class="el" href="classCircularBuffer.html" title="A template class that implements a circular or ring buffer.">CircularBuffer</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a01434fe991daa3020e26aa290bf37aaf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a01434fe991daa3020e26aa290bf37aaf">&#9670;&nbsp;</a></span>append() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , bool always_accept_data_when_full = true, typename Alloc  = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classCircularBuffer.html">CircularBuffer</a>&lt; T, always_accept_data_when_full, Alloc &gt;::append </td>
          <td>(</td>
          <td class="paramtype">const QList&lt; value_type &gt;&#160;</td>
          <td class="paramname"><em>values</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Pushes a new item at the head position. </p>
<p>This is an overloaded function. It is the equivalent of <a class="el" href="classCircularBuffer.html#ab5da153a3f7c33b972f4f91694813c97" title="Pushes a new item at the head position.">push()</a>.</p>
<p>Note: You should check if there is space to enter more data before adding more as it will overwrite the oldest data if there is insufficient space available.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">values</td><td>- an object of type value_type. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac084fd3bc6096ea544950508ef5c949e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac084fd3bc6096ea544950508ef5c949e">&#9670;&nbsp;</a></span>append() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , bool always_accept_data_when_full = true, typename Alloc  = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classCircularBuffer.html">CircularBuffer</a>&lt; T, always_accept_data_when_full, Alloc &gt;::append </td>
          <td>(</td>
          <td class="paramtype">const QVector&lt; value_type &gt; &amp;&#160;</td>
          <td class="paramname"><em>values</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Pushes a vector of items to the buffer. </p>
<p>This is an overloaded function.</p>
<p>This will push the items to the buffer but does not alter the size of the buffer so if the vector is too large onle the last N items will be stored where N = the capacity of the buffer.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">values</td><td>- a QVector of type value_type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classCircularBuffer.html#ab5da153a3f7c33b972f4f91694813c97" title="Pushes a new item at the head position.">push()</a> </dd></dl>

</div>
</div>
<a id="a6a3ccbdb781cce2a2799c52af68ecd48"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6a3ccbdb781cce2a2799c52af68ecd48">&#9670;&nbsp;</a></span>append() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , bool always_accept_data_when_full = true, typename Alloc  = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classCircularBuffer.html">CircularBuffer</a>&lt; T, always_accept_data_when_full, Alloc &gt;::append </td>
          <td>(</td>
          <td class="paramtype">const value_type &amp;&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Pushes a new item at the head position. </p>
<p>This is an overloaded function. It is the equivalent of <a class="el" href="classCircularBuffer.html#ab5da153a3f7c33b972f4f91694813c97" title="Pushes a new item at the head position.">push()</a>.</p>
<p>Note: You should check if there is space to enter more data before adding more as it will overwrite the oldest data if there is insufficient space available.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>- an object of type value_type. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a11000942e29ce9625dc35683becef9e0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a11000942e29ce9625dc35683becef9e0">&#9670;&nbsp;</a></span>at() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , bool always_accept_data_when_full = true, typename Alloc  = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">reference <a class="el" href="classCircularBuffer.html">CircularBuffer</a>&lt; T, always_accept_data_when_full, Alloc &gt;::at </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Access the element at index, relative to the tail of the buffer. </p>
<p>index must be a valid index position in the buffer (i.e., 0 &lt;= i &lt; <a class="el" href="classCircularBuffer.html#a6600179eace34c6de4ae0781246ee0b4" title="Returns the number of items stored in the buffer.">size()</a>).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>- the index within the buffer. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>an object of type value_type. </dd></dl>

</div>
</div>
<a id="a5c4dfdd88975c243d17c0d7b623bc03c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5c4dfdd88975c243d17c0d7b623bc03c">&#9670;&nbsp;</a></span>at() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , bool always_accept_data_when_full = true, typename Alloc  = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const_reference <a class="el" href="classCircularBuffer.html">CircularBuffer</a>&lt; T, always_accept_data_when_full, Alloc &gt;::at </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Access the element at index, relative to the tail of the buffer. </p>
<p>index must be a valid index position in the buffer (i.e., 0 &lt;= i &lt; <a class="el" href="classCircularBuffer.html#a6600179eace34c6de4ae0781246ee0b4" title="Returns the number of items stored in the buffer.">size()</a>).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>- an int offset value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>an object of type value_type. </dd></dl>

</div>
</div>
<a id="a73b27a250169aea48f03a3187de6f238"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a73b27a250169aea48f03a3187de6f238">&#9670;&nbsp;</a></span>back() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , bool always_accept_data_when_full = true, typename Alloc  = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">reference <a class="el" href="classCircularBuffer.html">CircularBuffer</a>&lt; T, always_accept_data_when_full, Alloc &gt;::back </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Access the last element. </p>
<p>This is an overloaded function.</p>
<p>This function is provided for STL compatibility. It is equivalent to <a class="el" href="classCircularBuffer.html#a0e91cf81442adb22e413e2d1ec0d6177" title="Access the last element.">last()</a>.</p>
<dl class="section return"><dt>Returns</dt><dd>a reference to the last item in the vector. </dd></dl>

</div>
</div>
<a id="abc9dfa40c186a050982259c2493a1286"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abc9dfa40c186a050982259c2493a1286">&#9670;&nbsp;</a></span>back() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , bool always_accept_data_when_full = true, typename Alloc  = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const_reference <a class="el" href="classCircularBuffer.html">CircularBuffer</a>&lt; T, always_accept_data_when_full, Alloc &gt;::back </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Access the last element. </p>
<p>This is an overloaded function.</p>
<p>This function is provided for STL compatibility. It is equivalent to <a class="el" href="classCircularBuffer.html#a0e91cf81442adb22e413e2d1ec0d6177" title="Access the last element.">last()</a>.</p>
<dl class="section return"><dt>Returns</dt><dd>a const reference to the last item in the vector. </dd></dl>

</div>
</div>
<a id="a59530258197a44c29342291568f427bf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a59530258197a44c29342291568f427bf">&#9670;&nbsp;</a></span>capacity()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , bool always_accept_data_when_full = true, typename Alloc  = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classCircularBuffer.html">CircularBuffer</a>&lt; T, always_accept_data_when_full, Alloc &gt;::capacity </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the total capacity of the buffer. </p>
<dl class="section return"><dt>Returns</dt><dd>- an int value. </dd></dl>

</div>
</div>
<a id="a926ea46b3d459ec32db2a420d7b5a640"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a926ea46b3d459ec32db2a420d7b5a640">&#9670;&nbsp;</a></span>constFirst()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , bool always_accept_data_when_full = true, typename Alloc  = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const_reference&amp; <a class="el" href="classCircularBuffer.html">CircularBuffer</a>&lt; T, always_accept_data_when_full, Alloc &gt;::constFirst </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Access the first element. </p>
<p>This is an overloaded function. It is equivalent to <a class="el" href="classCircularBuffer.html#a5fc2878ede1b6b8c2612f77a0b4752c5" title="Access the first element.">first()</a>.</p>
<dl class="section return"><dt>Returns</dt><dd>a const reference to the first item in the vector. </dd></dl>

</div>
</div>
<a id="affcb65586740b7873cd7c91467aa98fa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#affcb65586740b7873cd7c91467aa98fa">&#9670;&nbsp;</a></span>constFront()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , bool always_accept_data_when_full = true, typename Alloc  = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const_reference&amp; <a class="el" href="classCircularBuffer.html">CircularBuffer</a>&lt; T, always_accept_data_when_full, Alloc &gt;::constFront </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Access the first element. </p>
<p>This is an overloaded function. It is equivalent to <a class="el" href="classCircularBuffer.html#a5fc2878ede1b6b8c2612f77a0b4752c5" title="Access the first element.">first()</a>.</p>
<dl class="section return"><dt>Returns</dt><dd>a const reference to the first item in the vector. </dd></dl>

</div>
</div>
<a id="ab50bbd5c853bdae84d201e95cfbc1dcd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab50bbd5c853bdae84d201e95cfbc1dcd">&#9670;&nbsp;</a></span>constLast()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , bool always_accept_data_when_full = true, typename Alloc  = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const_reference <a class="el" href="classCircularBuffer.html">CircularBuffer</a>&lt; T, always_accept_data_when_full, Alloc &gt;::constLast </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Access the last element. </p>
<p>This is an overloaded function. It is equivalent to <a class="el" href="classCircularBuffer.html#a0e91cf81442adb22e413e2d1ec0d6177" title="Access the last element.">last()</a>.</p>
<dl class="section return"><dt>Returns</dt><dd>a const reference to the last item in the vector. </dd></dl>

</div>
</div>
<a id="a6ec5132660c3a9c41f6c0584e74c4a8b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6ec5132660c3a9c41f6c0584e74c4a8b">&#9670;&nbsp;</a></span>count()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , bool always_accept_data_when_full = true, typename Alloc  = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classCircularBuffer.html">CircularBuffer</a>&lt; T, always_accept_data_when_full, Alloc &gt;::count </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the number of items stored in the buffer. </p>
<p>This is an overloaded function, the equivalent of <a class="el" href="classCircularBuffer.html#a6600179eace34c6de4ae0781246ee0b4" title="Returns the number of items stored in the buffer.">size()</a>. </p>

</div>
</div>
<a id="a1d7cc7952570f9066b2c278f503444cb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1d7cc7952570f9066b2c278f503444cb">&#9670;&nbsp;</a></span>fill()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , bool always_accept_data_when_full = true, typename Alloc  = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classCircularBuffer.html">CircularBuffer</a>&lt; T, always_accept_data_when_full, Alloc &gt;::fill </td>
          <td>(</td>
          <td class="paramtype">value_type &amp;&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>size</em> = <code>-1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Assigns value to all, or size, items in the vector. </p>
<p>If size is -1 (the default), or size is greater than the available items then all of the available items are set to 'value', however if size is less than the available items only that number of items is set to 'value'.</p>
<p>Generally you will not need to use this method as default values are automatically entered.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>- the value_type value to fill the buffer with. </td></tr>
    <tr><td class="paramname">size</td><td>- the number of slots to fill. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5fc2878ede1b6b8c2612f77a0b4752c5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5fc2878ede1b6b8c2612f77a0b4752c5">&#9670;&nbsp;</a></span>first() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , bool always_accept_data_when_full = true, typename Alloc  = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">reference <a class="el" href="classCircularBuffer.html">CircularBuffer</a>&lt; T, always_accept_data_when_full, Alloc &gt;::first </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Access the first element. </p>
<p>This function assumes that the vector isn't empty.</p>
<dl class="section return"><dt>Returns</dt><dd>a reference to the first item in the vector. </dd></dl>

</div>
</div>
<a id="a4847cd4379d1ce36055b0cf74ddc4acf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4847cd4379d1ce36055b0cf74ddc4acf">&#9670;&nbsp;</a></span>first() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , bool always_accept_data_when_full = true, typename Alloc  = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const_reference&amp; <a class="el" href="classCircularBuffer.html">CircularBuffer</a>&lt; T, always_accept_data_when_full, Alloc &gt;::first </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Access the first element. </p>
<p>This is an overloaded function. This function assumes that the vector isn't empty.</p>
<dl class="section return"><dt>Returns</dt><dd>a const reference to the first item in the vector. </dd></dl>

</div>
</div>
<a id="a1d3b8caeed73e0384045ba4f4081f15b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1d3b8caeed73e0384045ba4f4081f15b">&#9670;&nbsp;</a></span>front() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , bool always_accept_data_when_full = true, typename Alloc  = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">reference <a class="el" href="classCircularBuffer.html">CircularBuffer</a>&lt; T, always_accept_data_when_full, Alloc &gt;::front </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Access the first element. </p>
<p>This is an overloaded function.</p>
<p>This function is provided for STL compatibility. It is equivalent to <a class="el" href="classCircularBuffer.html#a5fc2878ede1b6b8c2612f77a0b4752c5" title="Access the first element.">first()</a>.</p>
<dl class="section return"><dt>Returns</dt><dd>a reference to the first item in the vector. </dd></dl>

</div>
</div>
<a id="a6ff6b930a002cef801b4722bb92c762d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6ff6b930a002cef801b4722bb92c762d">&#9670;&nbsp;</a></span>front() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , bool always_accept_data_when_full = true, typename Alloc  = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const_reference <a class="el" href="classCircularBuffer.html">CircularBuffer</a>&lt; T, always_accept_data_when_full, Alloc &gt;::front </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Access the first element. </p>
<p>This is an overloaded function.</p>
<p>This function is provided for STL compatibility. It is equivalent to <a class="el" href="classCircularBuffer.html#a5fc2878ede1b6b8c2612f77a0b4752c5" title="Access the first element.">first()</a>.</p>
<dl class="section return"><dt>Returns</dt><dd>a const reference to the first item in the vector. </dd></dl>

</div>
</div>
<a id="a2ccd41c830b60c72a1d8605fecde67e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2ccd41c830b60c72a1d8605fecde67e5">&#9670;&nbsp;</a></span>get() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , bool always_accept_data_when_full = true, typename Alloc  = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const value_type <a class="el" href="classCircularBuffer.html">CircularBuffer</a>&lt; T, always_accept_data_when_full, Alloc &gt;::get </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>pulls an item from the front position and returns it. </p>
<p>The item is removed and the back position is incremented by one position.</p>
<dl class="section return"><dt>Returns</dt><dd>- an object of type value_type. </dd></dl>

</div>
</div>
<a id="a090c9c6ec8f544fd19c2b6a0055c1805"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a090c9c6ec8f544fd19c2b6a0055c1805">&#9670;&nbsp;</a></span>get() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , bool always_accept_data_when_full = true, typename Alloc  = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const QVector&lt;value_type&gt; <a class="el" href="classCircularBuffer.html">CircularBuffer</a>&lt; T, always_accept_data_when_full, Alloc &gt;::get </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>count</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>pulls an count items from the front position. </p>
<p>The items are removed and the front position is incremented by count positions, or <a class="el" href="classCircularBuffer.html#a6600179eace34c6de4ae0781246ee0b4" title="Returns the number of items stored in the buffer.">size()</a> positions if the buffer size is less than count.</p>
<dl class="section return"><dt>Returns</dt><dd>- an object of type value_type. </dd></dl>

</div>
</div>
<a id="a3981716c7fd8d014a02fafd6b3db1e62"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3981716c7fd8d014a02fafd6b3db1e62">&#9670;&nbsp;</a></span>isEmpty()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , bool always_accept_data_when_full = true, typename Alloc  = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classCircularBuffer.html">CircularBuffer</a>&lt; T, always_accept_data_when_full, Alloc &gt;::isEmpty </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks if the buffer is empty. </p>
<p>This is an overloaded function, the equivalent of <a class="el" href="classCircularBuffer.html#a2078a5f761bbe226681a422b1f35d0bb" title="Checks if the buffer is empty.">empty()</a>. </p>

</div>
</div>
<a id="a6c6bc2d47789b7a5d1b61b65b18df9a2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6c6bc2d47789b7a5d1b61b65b18df9a2">&#9670;&nbsp;</a></span>isFull()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , bool always_accept_data_when_full = true, typename Alloc  = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classCircularBuffer.html">CircularBuffer</a>&lt; T, always_accept_data_when_full, Alloc &gt;::isFull </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks if the buffer is full. </p>
<dl class="section return"><dt>Returns</dt><dd>true if full, otherwise false. </dd></dl>

</div>
</div>
<a id="a0e91cf81442adb22e413e2d1ec0d6177"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0e91cf81442adb22e413e2d1ec0d6177">&#9670;&nbsp;</a></span>last() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , bool always_accept_data_when_full = true, typename Alloc  = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">reference <a class="el" href="classCircularBuffer.html">CircularBuffer</a>&lt; T, always_accept_data_when_full, Alloc &gt;::last </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Access the last element. </p>
<p>This function is provided for STL compatibility.</p>
<dl class="section return"><dt>Returns</dt><dd>a const reference to the last item in the vector. </dd></dl>

</div>
</div>
<a id="ab56ae7118e07ac69180e26f1f6b44cb3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab56ae7118e07ac69180e26f1f6b44cb3">&#9670;&nbsp;</a></span>last() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , bool always_accept_data_when_full = true, typename Alloc  = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const_reference <a class="el" href="classCircularBuffer.html">CircularBuffer</a>&lt; T, always_accept_data_when_full, Alloc &gt;::last </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Access the last element. </p>
<p>This is an overloaded function.</p>
<p>This function is provided for STL compatibility.</p>
<dl class="section return"><dt>Returns</dt><dd>a const reference to the last item in the vector. </dd></dl>

</div>
</div>
<a id="ac0e3d8da20b284f9159309e6e4d60273"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac0e3d8da20b284f9159309e6e4d60273">&#9670;&nbsp;</a></span>length()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , bool always_accept_data_when_full = true, typename Alloc  = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classCircularBuffer.html">CircularBuffer</a>&lt; T, always_accept_data_when_full, Alloc &gt;::length </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the number of items stored in the buffer. </p>
<p>This is an overloaded function, the equivalent of <a class="el" href="classCircularBuffer.html#a6600179eace34c6de4ae0781246ee0b4" title="Returns the number of items stored in the buffer.">size()</a>. </p>

</div>
</div>
<a id="a563e9dca98c880f12c8ba0ddbd5eccbd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a563e9dca98c880f12c8ba0ddbd5eccbd">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , bool always_accept_data_when_full = true, typename Alloc  = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classCircularBuffer.html">CircularBuffer</a>&lt;value_type&gt;&amp; <a class="el" href="classCircularBuffer.html">CircularBuffer</a>&lt; T, always_accept_data_when_full, Alloc &gt;::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">const QList&lt; value_type &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Pushes a list of items to the buffer. </p>
<p>This will push the items to the buffer but does not alter the size of the buffer so if the list is too large onle the last N items will be stored where N = the capacity of the buffer.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>- a const QList of type value_type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd>CircularBuffer::push(QVector&lt;value_type&gt;) </dd></dl>

</div>
</div>
<a id="ab3a94923b0319035036187a63ce4e760"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab3a94923b0319035036187a63ce4e760">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , bool always_accept_data_when_full = true, typename Alloc  = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classCircularBuffer.html">CircularBuffer</a>&lt;value_type&gt;&amp; <a class="el" href="classCircularBuffer.html">CircularBuffer</a>&lt; T, always_accept_data_when_full, Alloc &gt;::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">const QVector&lt; value_type &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Pushes a vector of items to the buffer. </p>
<p>This will push the items to the buffer but does not alter the size of the buffer so if the list is too large onle the last N items will be stored where N = the capacity of the buffer.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>- a const QVector of type value_type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd>CircularBuffer::push(QVector&lt;value_type&gt;) </dd></dl>

</div>
</div>
<a id="aa9afaff501c953375a85cf634a27f3c1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa9afaff501c953375a85cf634a27f3c1">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , bool always_accept_data_when_full = true, typename Alloc  = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classCircularBuffer.html">CircularBuffer</a>&lt;value_type&gt;&amp; <a class="el" href="classCircularBuffer.html">CircularBuffer</a>&lt; T, always_accept_data_when_full, Alloc &gt;::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">const value_type&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Pushes a new item at the head position. </p>
<p>Note: You should check if there is space to enter more data before adding more as it will overwrite the oldest data if there is insufficient space available.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>- an constant object of type value_type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classCircularBuffer.html#ab5da153a3f7c33b972f4f91694813c97" title="Pushes a new item at the head position.">CircularBuffer::push()</a> </dd></dl>

</div>
</div>
<a id="a03a4250a22aeb8777ee17fa192d8ac36"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a03a4250a22aeb8777ee17fa192d8ac36">&#9670;&nbsp;</a></span>operator[]() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , bool always_accept_data_when_full = true, typename Alloc  = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">reference <a class="el" href="classCircularBuffer.html">CircularBuffer</a>&lt; T, always_accept_data_when_full, Alloc &gt;::operator[] </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the value at the index, relative to the tail of the buffer. </p>
<p>A similar operator <a class="el" href="classCircularBuffer.html#a11000942e29ce9625dc35683becef9e0" title="Access the element at index, relative to the tail of the buffer.">at()</a> can also be used. The difference is that <a class="el" href="classCircularBuffer.html#a11000942e29ce9625dc35683becef9e0" title="Access the element at index, relative to the tail of the buffer.">at()</a> is bounds checked and throws an std::out_of_bounds exception if index is outside the size of the buffer. In this case this causes undefined behaviour.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>- an int offset value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a reference to the item at index. </dd></dl>

</div>
</div>
<a id="a29fff81d518245ded92a4d1f433e3778"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a29fff81d518245ded92a4d1f433e3778">&#9670;&nbsp;</a></span>operator[]() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , bool always_accept_data_when_full = true, typename Alloc  = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const_reference <a class="el" href="classCircularBuffer.html">CircularBuffer</a>&lt; T, always_accept_data_when_full, Alloc &gt;::operator[] </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the value at the index, relative to the tail of the buffer. </p>
<p>A similar operator <a class="el" href="classCircularBuffer.html#a11000942e29ce9625dc35683becef9e0" title="Access the element at index, relative to the tail of the buffer.">at()</a> can also be used. The difference is that <a class="el" href="classCircularBuffer.html#a11000942e29ce9625dc35683becef9e0" title="Access the element at index, relative to the tail of the buffer.">at()</a> is bounds checked and throws an std::out_of_bounds exception if index is outside the size of the buffer. In this case this causes undefined behaviour.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>- an int offset value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a const reference to the item at index. </dd></dl>

</div>
</div>
<a id="a81a09a6e0d8567d5b9af9f956bd7be55"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a81a09a6e0d8567d5b9af9f956bd7be55">&#9670;&nbsp;</a></span>pop()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , bool always_accept_data_when_full = true, typename Alloc  = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classCircularBuffer.html">CircularBuffer</a>&lt; T, always_accept_data_when_full, Alloc &gt;::pop </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Deletes the first element. </p>
<p>To access the first element use <a class="el" href="classCircularBuffer.html#a1d3b8caeed73e0384045ba4f4081f15b" title="Access the first element.">CircularBuffer::front()</a> or <a class="el" href="classCircularBuffer.html#a5fc2878ede1b6b8c2612f77a0b4752c5" title="Access the first element.">CircularBuffer::first()</a>. </p>

</div>
</div>
<a id="abde089c9e08735367fb80783be334780"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abde089c9e08735367fb80783be334780">&#9670;&nbsp;</a></span>pop_front()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , bool always_accept_data_when_full = true, typename Alloc  = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classCircularBuffer.html">CircularBuffer</a>&lt; T, always_accept_data_when_full, Alloc &gt;::pop_front </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Deletes the first element. </p>
<p>This is an overloaded function. It is the equivalent of <a class="el" href="classCircularBuffer.html#a81a09a6e0d8567d5b9af9f956bd7be55" title="Deletes the first element.">pop()</a>. </p>

</div>
</div>
<a id="a3ca2994bd5cce14dc72ecd1d5bb40fdc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3ca2994bd5cce14dc72ecd1d5bb40fdc">&#9670;&nbsp;</a></span>popFirst()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , bool always_accept_data_when_full = true, typename Alloc  = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classCircularBuffer.html">CircularBuffer</a>&lt; T, always_accept_data_when_full, Alloc &gt;::popFirst </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Deletes the first element. </p>
<p>This is an overloaded function. It is the equivalent of <a class="el" href="classCircularBuffer.html#a81a09a6e0d8567d5b9af9f956bd7be55" title="Deletes the first element.">pop()</a>. </p>

</div>
</div>
<a id="aef1791c6160fe8daa0d84c4788a4bbc4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aef1791c6160fe8daa0d84c4788a4bbc4">&#9670;&nbsp;</a></span>popFront()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , bool always_accept_data_when_full = true, typename Alloc  = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classCircularBuffer.html">CircularBuffer</a>&lt; T, always_accept_data_when_full, Alloc &gt;::popFront </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Deletes the first element. </p>
<p>This is an overloaded function. It is the equivalent of <a class="el" href="classCircularBuffer.html#a81a09a6e0d8567d5b9af9f956bd7be55" title="Deletes the first element.">pop()</a>. </p>

</div>
</div>
<a id="a63a93aa0b1a6e6c14a2180ecb9be231b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a63a93aa0b1a6e6c14a2180ecb9be231b">&#9670;&nbsp;</a></span>pullList()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , bool always_accept_data_when_full = true, typename Alloc  = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const QList&lt;value_type&gt; <a class="el" href="classCircularBuffer.html">CircularBuffer</a>&lt; T, always_accept_data_when_full, Alloc &gt;::pullList </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Access the data as a QList. </p>
<p>The buffer is empty and the end of this.</p>
<dl class="section return"><dt>Returns</dt><dd>a vector of values. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classCircularBuffer.html#ab4edf2083cb71ee06c6249cf0f486f83" title="Access the data as a QList.">toList()</a> </dd></dl>

</div>
</div>
<a id="a0ad8aece5983ba783632a7daf2ccad22"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0ad8aece5983ba783632a7daf2ccad22">&#9670;&nbsp;</a></span>pullStdList()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , bool always_accept_data_when_full = true, typename Alloc  = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::list&lt;value_type&gt; <a class="el" href="classCircularBuffer.html">CircularBuffer</a>&lt; T, always_accept_data_when_full, Alloc &gt;::pullStdList </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Access the data as a QList. </p>
<p>The buffer is empty and the end of this.</p>
<dl class="section return"><dt>Returns</dt><dd>a vector of values. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classCircularBuffer.html#a56ffb6a42f0377c2ada4b2ff03db23a3" title="Access the data as a std::list.">toStdList()</a> </dd></dl>

</div>
</div>
<a id="adb0282ed740c6dd8f58e5645d3670836"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adb0282ed740c6dd8f58e5645d3670836">&#9670;&nbsp;</a></span>pullStdVector()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , bool always_accept_data_when_full = true, typename Alloc  = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::vector&lt;value_type&gt; <a class="el" href="classCircularBuffer.html">CircularBuffer</a>&lt; T, always_accept_data_when_full, Alloc &gt;::pullStdVector </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Access the data as a std::vector. </p>
<dl class="section return"><dt>Returns</dt><dd>a vector of values. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classCircularBuffer.html#a69996ee0803ab3543f4904d4fc5c9985" title="Access the data as a std::vector.">toStdVector()</a> </dd></dl>

</div>
</div>
<a id="ae21ff905f06a74db2dce6bc3527ec4d3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae21ff905f06a74db2dce6bc3527ec4d3">&#9670;&nbsp;</a></span>pullVector()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , bool always_accept_data_when_full = true, typename Alloc  = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const QVector&lt;value_type&gt; <a class="el" href="classCircularBuffer.html">CircularBuffer</a>&lt; T, always_accept_data_when_full, Alloc &gt;::pullVector </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Access the data as a QVector, emptying the buffer. </p>
<dl class="section return"><dt>Returns</dt><dd>a QVector of values. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classCircularBuffer.html#ad2f7f8e6edc9189b8938222776bcbe68" title="Access the data as a QVector.">toVector()</a> </dd></dl>

</div>
</div>
<a id="a91f5d316f1fae066fdeb1978155479d7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a91f5d316f1fae066fdeb1978155479d7">&#9670;&nbsp;</a></span>push() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , bool always_accept_data_when_full = true, typename Alloc  = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classCircularBuffer.html">CircularBuffer</a>&lt; T, always_accept_data_when_full, Alloc &gt;::push </td>
          <td>(</td>
          <td class="paramtype">const QList&lt; value_type &gt;&#160;</td>
          <td class="paramname"><em>values</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Pushes a list of items to the buffer. </p>
<p>This will push the items to the buffer but does not alter the size of the buffer so if the list is too large onle the last N items will be stored where N = the capacity of the buffer.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">values</td><td>- a QList of type value_type. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9305ca519cd0d7bc850298709d2d043e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9305ca519cd0d7bc850298709d2d043e">&#9670;&nbsp;</a></span>push() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , bool always_accept_data_when_full = true, typename Alloc  = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classCircularBuffer.html">CircularBuffer</a>&lt; T, always_accept_data_when_full, Alloc &gt;::push </td>
          <td>(</td>
          <td class="paramtype">const QVector&lt; value_type &gt; &amp;&#160;</td>
          <td class="paramname"><em>values</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Pushes a vector of items to the buffer. </p>
<p>This will push the items to the buffer but does not alter the size of the buffer so if the vector is too large onle the last N items will be stored where N = the capacity of the buffer.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">values</td><td>- a QVector of type value_type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classCircularBuffer.html#ab5da153a3f7c33b972f4f91694813c97" title="Pushes a new item at the head position.">push()</a> </dd></dl>

</div>
</div>
<a id="ab5da153a3f7c33b972f4f91694813c97"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab5da153a3f7c33b972f4f91694813c97">&#9670;&nbsp;</a></span>push() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , bool always_accept_data_when_full = true, typename Alloc  = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classCircularBuffer.html">CircularBuffer</a>&lt; T, always_accept_data_when_full, Alloc &gt;::push </td>
          <td>(</td>
          <td class="paramtype">const value_type &amp;&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Pushes a new item at the head position. </p>
<p>Note: You should check if there is space to enter more data before adding more as it will overwrite the oldest data if there is insufficient space available.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>- an object of type value_type. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a29b56924fc7cb412ed89e32d8322a508"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a29b56924fc7cb412ed89e32d8322a508">&#9670;&nbsp;</a></span>push_back()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , bool always_accept_data_when_full = true, typename Alloc  = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classCircularBuffer.html">CircularBuffer</a>&lt; T, always_accept_data_when_full, Alloc &gt;::push_back </td>
          <td>(</td>
          <td class="paramtype">const value_type &amp;&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Pushes a new item at the head position. </p>
<p>This is an overloaded function. It is the equivalent of <a class="el" href="classCircularBuffer.html#ab5da153a3f7c33b972f4f91694813c97" title="Pushes a new item at the head position.">push()</a>.</p>
<p>Note: You should check if there is space to enter more data before adding more as it will overwrite the oldest data if there is insufficient space available.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>- an object of type value_type. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae0a7b658a605d6421c9bb187a5e1f406"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae0a7b658a605d6421c9bb187a5e1f406">&#9670;&nbsp;</a></span>removeFirst()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , bool always_accept_data_when_full = true, typename Alloc  = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classCircularBuffer.html">CircularBuffer</a>&lt; T, always_accept_data_when_full, Alloc &gt;::removeFirst </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Deletes the first element. </p>
<p>This is an overloaded function. It is the equivalent of <a class="el" href="classCircularBuffer.html#a81a09a6e0d8567d5b9af9f956bd7be55" title="Deletes the first element.">pop()</a>. </p>

</div>
</div>
<a id="abd0bd3ff763b344c9a9c514dd044f32c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abd0bd3ff763b344c9a9c514dd044f32c">&#9670;&nbsp;</a></span>reserve()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , bool always_accept_data_when_full = true, typename Alloc  = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classCircularBuffer.html">CircularBuffer</a>&lt; T, always_accept_data_when_full, Alloc &gt;::reserve </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>capacity</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Resizes the buffer to a new capacity. </p>
<p>Resizes the buffer to the supplied size. If the new capacity is larger then all of the old will be retained, otherwise only the most recent additions will be retained.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">capacity</td><td>- the capacity value. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a88ce5231f66d39548844703f93cd4bf9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a88ce5231f66d39548844703f93cd4bf9">&#9670;&nbsp;</a></span>takeFirst()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , bool always_accept_data_when_full = true, typename Alloc  = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const value_type <a class="el" href="classCircularBuffer.html">CircularBuffer</a>&lt; T, always_accept_data_when_full, Alloc &gt;::takeFirst </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>pulls an item from the front position and returns it. </p>
<p>This is an overloaded function.</p>
<p>The item is removed and the back position is incremented by one position.</p>
<dl class="section return"><dt>Returns</dt><dd>- an object of type value_type. </dd></dl>
<dl class="section see"><dt>See also</dt><dd>pull() </dd></dl>

</div>
</div>
<a id="a28e14174200a3d99e53da805da70d003"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a28e14174200a3d99e53da805da70d003">&#9670;&nbsp;</a></span>takeFront()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , bool always_accept_data_when_full = true, typename Alloc  = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const value_type <a class="el" href="classCircularBuffer.html">CircularBuffer</a>&lt; T, always_accept_data_when_full, Alloc &gt;::takeFront </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>pulls an item from the front position and returns it. </p>
<p>This is an overloaded function.</p>
<p>The item is removed and the back position is incremented by one position.</p>
<dl class="section return"><dt>Returns</dt><dd>- an object of type value_type. </dd></dl>
<dl class="section see"><dt>See also</dt><dd>pull() </dd></dl>

</div>
</div>
<a id="ab4edf2083cb71ee06c6249cf0f486f83"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab4edf2083cb71ee06c6249cf0f486f83">&#9670;&nbsp;</a></span>toList()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , bool always_accept_data_when_full = true, typename Alloc  = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const QList&lt;value_type&gt; <a class="el" href="classCircularBuffer.html">CircularBuffer</a>&lt; T, always_accept_data_when_full, Alloc &gt;::toList </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Access the data as a QList. </p>
<p>If you want to remove the data, you can use <a class="el" href="classCircularBuffer.html#a63a93aa0b1a6e6c14a2180ecb9be231b" title="Access the data as a QList.">pullList()</a>.</p>
<dl class="section return"><dt>Returns</dt><dd>a vector of values. </dd></dl>

</div>
</div>
<a id="a56ffb6a42f0377c2ada4b2ff03db23a3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a56ffb6a42f0377c2ada4b2ff03db23a3">&#9670;&nbsp;</a></span>toStdList()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , bool always_accept_data_when_full = true, typename Alloc  = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::list&lt;value_type&gt; <a class="el" href="classCircularBuffer.html">CircularBuffer</a>&lt; T, always_accept_data_when_full, Alloc &gt;::toStdList </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Access the data as a std::list. </p>
<p>If you want to remove the data, you can use <a class="el" href="classCircularBuffer.html#a0ad8aece5983ba783632a7daf2ccad22" title="Access the data as a QList.">pullStdList()</a>.</p>
<dl class="section return"><dt>Returns</dt><dd>a vector of values. </dd></dl>

</div>
</div>
<a id="a69996ee0803ab3543f4904d4fc5c9985"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a69996ee0803ab3543f4904d4fc5c9985">&#9670;&nbsp;</a></span>toStdVector()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , bool always_accept_data_when_full = true, typename Alloc  = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::vector&lt;value_type&gt; <a class="el" href="classCircularBuffer.html">CircularBuffer</a>&lt; T, always_accept_data_when_full, Alloc &gt;::toStdVector </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Access the data as a std::vector. </p>
<p>If you want to remove the data, you can use <a class="el" href="classCircularBuffer.html#adb0282ed740c6dd8f58e5645d3670836" title="Access the data as a std::vector.">pullStdVector()</a>.</p>
<dl class="section return"><dt>Returns</dt><dd>a vector of values. </dd></dl>

</div>
</div>
<a id="ad2f7f8e6edc9189b8938222776bcbe68"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad2f7f8e6edc9189b8938222776bcbe68">&#9670;&nbsp;</a></span>toVector()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , bool always_accept_data_when_full = true, typename Alloc  = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const QVector&lt;value_type&gt; <a class="el" href="classCircularBuffer.html">CircularBuffer</a>&lt; T, always_accept_data_when_full, Alloc &gt;::toVector </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Access the data as a QVector. </p>
<p>If you want to remove the data, you can use <a class="el" href="classCircularBuffer.html#ae21ff905f06a74db2dce6bc3527ec4d3" title="Access the data as a QVector, emptying the buffer.">pullVector()</a>.</p>
<dl class="section return"><dt>Returns</dt><dd>a QVector of values. </dd></dl>

</div>
</div>
<a id="ab49b0c13f2a4af3efbddf5832614d6a0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab49b0c13f2a4af3efbddf5832614d6a0">&#9670;&nbsp;</a></span>value() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , bool always_accept_data_when_full = true, typename Alloc  = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">value_type <a class="el" href="classCircularBuffer.html">CircularBuffer</a>&lt; T, always_accept_data_when_full, Alloc &gt;::value </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Access the element at index, relative to the tail of the buffer. </p>
<p>If the index i is out of bounds, the function returns a default-constructed value. If you are certain that i is within bounds, you can use <a class="el" href="classCircularBuffer.html#a11000942e29ce9625dc35683becef9e0" title="Access the element at index, relative to the tail of the buffer.">at()</a> instead which is slightly faster.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>- the index within the buffer. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>an object of type value_type. </dd></dl>

</div>
</div>
<a id="acadfcf767d3efcfed33d6c08cd8c98c1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acadfcf767d3efcfed33d6c08cd8c98c1">&#9670;&nbsp;</a></span>value() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , bool always_accept_data_when_full = true, typename Alloc  = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">value_type <a class="el" href="classCircularBuffer.html">CircularBuffer</a>&lt; T, always_accept_data_when_full, Alloc &gt;::value </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const value_type&#160;</td>
          <td class="paramname"><em>defaultValue</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Access the element at index, relative to the tail of the buffer or a supplied default value. </p>
<p>This is an overloaded function.</p>
<p>If the index i is out of bounds, the function returns a default-constructed value. If you are certain that i is within bounds, you can use <a class="el" href="classCircularBuffer.html#a11000942e29ce9625dc35683becef9e0" title="Access the element at index, relative to the tail of the buffer.">at()</a> instead which is slightly faster.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>- the index within the buffer. </td></tr>
    <tr><td class="paramname">defaultValue</td><td>- the default item to use to fill the buffer. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>an object of type value_type. </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="CircularBuffer_8h_source.html">CircularBuffer.h</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
